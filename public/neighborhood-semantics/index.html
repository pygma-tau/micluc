<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neighborhood Semantics</title>
    <link rel="stylesheet" href="https://yudhister.me/style.css">
    <!-- MathJax for LaTeX rendering -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script>
		window.MathJax = {
		  tex: {
			inlineMath: [['$','$'], ['\\(','\\)']],
			displayMath: [ ['$$','$$'], ["\\[","\\]"], ]
		  },
		  startup: {
			ready: () => {
					// Function to iterate over all pre and code elements
					// if they contain TeX/LaTeX code for maths as defined
					// by the markers in tex settings above then copy their
					// textContent before them and remove the element from
					// the DOM. 
					
					// get pre and code elements
					var prelist = document.getElementsByTagName("pre");
					var codelist = document.getElementsByTagName("code");
					// get delimiters for inline and display math
					var inline = MathJax.config.tex.inlineMath;
					var display = MathJax.config.tex.displayMath;
					// start building  a RegExp for each of these math types
					var inlineRegexList = [];
					var displayRegexList =[];
					for(i=0;i<inline.length;i++) {
						// https://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
						delimLEsc = inline[i][0].replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
						//alert(delimLEsc);
						delimREsc = inline[i][1].replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
						inlineRegexList.push("("+delimLEsc+")((.|[\\r\\n\\t])*?)("+delimREsc+")");
					};
					for(i=0;i<display.length;i++) {
						// https://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
						delimLEsc = display[i][0].replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
						//alert(delimLEsc);
						delimREsc = display[i][1].replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
						displayRegexList.push("("+delimLEsc+")((.|[\\r\\n\\t])*?)("+delimREsc+")");
					};
					inlineRegExp = new RegExp(inlineRegexList.join("|"));
					displayRegExp = new RegExp(displayRegexList.join("|"));
					
					// iterate over pre elements applying RegExp
					// iterate "backwards" as we are removing elements!
					for (i=prelist.length; i>0; i--) {
						if(displayRegExp.test(prelist[i-1].textContent)) {
							var t = document.createTextNode(prelist[i-1].textContent);
							prelist[i-1].parentNode.insertBefore(t,prelist[i-1]);
							prelist[i-1].parentNode.removeChild(prelist[i-1]);
						}
					}
					// iterate over code elements applying RegExp
					// iterate "backwards" as we are removing elements!
					for (i=codelist.length; i>0; i--) {
						if(inlineRegExp.test(codelist[i-1].textContent)) {
							var t = document.createTextNode(codelist[i-1].textContent);
							codelist[i-1].parentNode.insertBefore(t,codelist[i-1]);
							codelist[i-1].parentNode.removeChild(codelist[i-1]);
						}
					}
			  // Now process the page in MathJax
			  MathJax.startup.defaultReady();
			}
		  }
		};
		</script>
		<script type="text/javascript" id="MathJax-script" async
		  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
		</script>
</head>
<body>
    <main>
        <h1>Neighborhood Semantics</h1>
        <p><i>June 17, 2024</i></p>
        <h2>Intro</h2>
<p>We start with a typical Kripke frame $\mathcal{F} = (\mathcal{W}, R)$ where $W$ is the set of possible worlds (think possible truth assignments to your set of propositional variables) and $R$ is a binary relation on those worlds. </p>
<p>A Kripke model is just some triple $(\mathcal{W}, R, \Vdash)$ where $\Vdash$ is the forcing relation which determines the relationship between various worlds $w\in\mathcal{W}$ and modal formulas. It's characterized by the following rules:</p>
<ul>
<li>$w \Vdash \neg A$ if and only if $w \not\Vdash A$</li>
<li>$w \Vdash A \to B$ if and only if $w \Vdash \neg A$ or $w \vdash B$</li>
<li>$w \Vdash \Box A$ if and only if for all $u$ satisfying $wRu$ we have that $u \Vdash A.$</li>
</ul>
<p>(this also subsequently implies that $A$ is possible in world $w$ if and only if it is true in at least one world $u$ adjacent to $w,$ because it's the dual of necessity)</p>
<p>Different modal logics are generated by changing the assumptions on $R$. For instance, forcing $R$ to be reflexive guarantees that $\textbf{T}: \Box A \to A$ will be satisfied. However, all Kripke models satisfy axiom $\textbf{K}: \Box (A \to B) \to (\Box A \to \Box B),$ which makes Kripke models very good for representing normal modal logics and very bad at representing non-normal modal logics. </p>
<p>Necessitation as an operator has become popular in representing agents' &quot;beliefs&quot;. E.g., you can take an agent, represent their policy in some modal logic, and $\Box \phi$ determines their belief in $\phi$ while $\vdash \phi$ determines whether or not $\phi$ is true in that world. And this is nice for a lot of things, and Kripke models are great for modeling provability logic, for instance.</p>
<p>But if we want necessity to be some sort of probabilistic operator---$\mathbb{P}(\phi) &gt; p$, for instance---then this becomes unsatisfactory. Probabilities don't distribute over conditionals like that. So we want to relax this somehow.</p>
<p>Enter neighborhood semantics. We define a neighborhood frame to be a pair $(\mathcal{W}, \mathcal{N}),$ where again $\mathcal{W}$ is the set of possible worlds and $\mathcal{N}: \mathcal{W} \to 2 ^ {2 ^ \mathcal{W}}$ is a &quot;neighborhood function&quot; which maps each world $w \in \mathcal{W}$ to a set of their neighborhoods.</p>
<p>Necessity here is defined differently: $w \Vdash \Box \phi$ if and only if the truth set of $\phi$ is a neighborhood of $w.$ That is, there has to be a neighborhood of $w$ that contains exactly all worlds in which $\phi$ is true, and then $w \Vdash \Box \phi.$ </p>
<p>It's easy to see that this is a generalization of a Kripke frame. You can convert every Kripke frame into a neighborhood frame by making the neighborhoods of each world exactly the truth sets of all $\phi$ that are necessitated by that world. </p>
<p>However, you can't go in reverse, because having different neighborhoods attached to the same world means that criterions for necessity can be different for each $\phi.$ For instance, $\Box \phi$ might be satisfied by a neighborhood $U$ which is disjoint from a neighborhood $V$ which satisfied $\Box \psi.$ This is not representable in Kripke models---there's only one neighborhood for each world.</p>
<p>You can pretty easily construct a world with neighborhood semantics that doesn't satisfy $\mathbf{K}.$ Or mainly, the neighborhood associated with $\Box(A \to B)$ doesn't have to be the same one associated with $\Box A,$ and then as a result this correspondence no longer holds in generality.</p>
<h2>Applications to Mathematical Reality</h2>
<p>Ok, so why were Kripke semantics useful in the first place? They provided a very clean structure by which they could model logics in a way that allowed one to verify properties like completeness/consistency/decidability well (all Kripke models are just graphs, in essence). Partially this is because they have some formal grounding in set theory. But also because formalizing logical structures as directed graphs is just <em>really powerful</em> and a <em>really useful abstraction</em> to reason about various systems.</p>
<p>In the same vein, reducing other systems to neighborhood semantics allows you to reason about their relevant properties simply and somewhat easily. Intuitively, we have a lot of structures that deal with collections of sets <em>cough topologies cough</em> and it'd be nice to bring some of them to the study of modal logic.</p>
<p>Then there's the question of what modal logics can simulate. Games feature prominently. Provability logic is quite famous. But more generally, modal logics are ways of <em>modeling systems and structures</em> that allow you to abstract away a bunch of irrelevant features.</p>
<p>(They're also all fragments of FOL (first-order-logic), and as a result don't necessarily have the same trials and tribulations that come with additional complexity) </p>

    </main>
    <nav>
        <ul>  
            <li>[<a href="/">Home</a>]</li>
            <li>[<a href="/now">Now</a>]</li>
            <li>[<a href="https://microdosinglucidity.com">Essays</a>]</li>
            <li>[<a href="/blog">Blog</a>]</li>
            <li>[<a href="/shelf">Shelf</a>]</li>
            <li>[<a href="https://twitter.com/yudhister_">Twitter</a>]</li>
            <li>[<a href="https://twitter.com/yudhister_">Curius</a>]</li>
        </ul>
    </nav>
</body>
</html>

