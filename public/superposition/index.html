<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Superposition</title>
    <link rel="stylesheet" href="https://yudhister.me/style.css">
    <!-- MathJax for LaTeX rendering -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script>
		window.MathJax = {
		  tex: {
			inlineMath: [['$','$'], ['\\(','\\)']],
			displayMath: [ ['$$','$$'], ["\\[","\\]"], ]
		  },
		  startup: {
			ready: () => {
					// Function to iterate over all pre and code elements
					// if they contain TeX/LaTeX code for maths as defined
					// by the markers in tex settings above then copy their
					// textContent before them and remove the element from
					// the DOM. 
					
					// get pre and code elements
					var prelist = document.getElementsByTagName("pre");
					var codelist = document.getElementsByTagName("code");
					// get delimiters for inline and display math
					var inline = MathJax.config.tex.inlineMath;
					var display = MathJax.config.tex.displayMath;
					// start building  a RegExp for each of these math types
					var inlineRegexList = [];
					var displayRegexList =[];
					for(i=0;i<inline.length;i++) {
						// https://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
						delimLEsc = inline[i][0].replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
						//alert(delimLEsc);
						delimREsc = inline[i][1].replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
						inlineRegexList.push("("+delimLEsc+")((.|[\\r\\n\\t])*?)("+delimREsc+")");
					};
					for(i=0;i<display.length;i++) {
						// https://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
						delimLEsc = display[i][0].replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
						//alert(delimLEsc);
						delimREsc = display[i][1].replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
						displayRegexList.push("("+delimLEsc+")((.|[\\r\\n\\t])*?)("+delimREsc+")");
					};
					inlineRegExp = new RegExp(inlineRegexList.join("|"));
					displayRegExp = new RegExp(displayRegexList.join("|"));
					
					// iterate over pre elements applying RegExp
					// iterate "backwards" as we are removing elements!
					for (i=prelist.length; i>0; i--) {
						if(displayRegExp.test(prelist[i-1].textContent)) {
							var t = document.createTextNode(prelist[i-1].textContent);
							prelist[i-1].parentNode.insertBefore(t,prelist[i-1]);
							prelist[i-1].parentNode.removeChild(prelist[i-1]);
						}
					}
					// iterate over code elements applying RegExp
					// iterate "backwards" as we are removing elements!
					for (i=codelist.length; i>0; i--) {
						if(inlineRegExp.test(codelist[i-1].textContent)) {
							var t = document.createTextNode(codelist[i-1].textContent);
							codelist[i-1].parentNode.insertBefore(t,codelist[i-1]);
							codelist[i-1].parentNode.removeChild(codelist[i-1]);
						}
					}
			  // Now process the page in MathJax
			  MathJax.startup.defaultReady();
			}
		  }
		};
		</script>
		<script type="text/javascript" id="MathJax-script" async
		  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
		</script>
</head>
<body>
    <main>
        <h1>Superposition</h1>
        <p><i>April 10, 2024</i></p>
        <p>Neuron activations have a <strong>privileged basis</strong>. The residual stream does not. This is because the nonlinearities are applied to the activations on an <em>element-wise</em> basis, which means that representing the non-linear computation under a change of basis gets messy and results in the <em>element-wise</em> computation no longer acting on <em>elements independently.</em> Another way of thinking about this is that the residual stream is rotation-independent because all interventions (reading/writing) to it are done via linear maps. Multiplying the writes by some rotation matrix $R$ and the reads by some rotation matrix $R^{-1}$ will leave the info &amp; computation done by the stream unchanged. IIRC this is also empirically shown in the grokking paper, where the algorithm is found up to rotation.</p>
<p>It seems that <strong>features</strong> is just the term we use to represent the units of a transformer's ontology. Alternative definitions include &quot;a property of an input to a model, or some subset of it&quot; (Neel) or &quot;[a] scalar function of the input&quot; (Chris Olah). Sometimes 'meaningful feature' is used to refer to features which are interpretable. However, Anthropic's toy model of bottleneck superposition just takes a 5-dim input $x$ and considers each dimension a feature in and of itself. This is more in line with Olah's definition? Maybe this confusion will resolve itself with practice.</p>
<p>Superposition itself is the phenomenon where there model <strong>represents more features than dimensions.</strong> In the Toy Models paper, Anthropic found that when features are dense models learn something like PCA, in that the two most important features have orthogonal representations and the rest are not learned. But as sparsity increases, we have the following: </p>
<img src="/images/superposed_features.png" width="600">
<p>Sparsity here is defined as the probability of the corresponding element in $x$ to the feature as being non-zero (e.g. is the feature represented in the input, roughly). We can also have different thresholds for sparsity that make sense, as in not nonzero but not above ~0.1. For instance, the second image has 80% sparsity because 4/5 of the features represented (and we assume that features are distributed evenly across the input set). In fact, it often makes sense (to me!) to think about sparsity as 1- feature probability rather than the other way around. </p>
<p>This is possible because sets of points in high-dimensional space can be embedded into a lower-dimension space in such a way that the distances between the points are nearly preserved by the <a href="https://transformer-circuits.pub/2022/toy_model/index.html">Johnson-Lindenstrauss lemma</a>. (I think this also implies that there can be exponentially many almost-orthogonal vectors in an n-dimensional space (exponential in the number of dimensions)). </p>
<p>Neel proposes two kinds of superposition: <strong>bottleneck superposition</strong> and <strong>neuron superposition</strong>:</p>
<ul>
<li><strong>bottleneck superposition</strong> occurs in places like keys, queries, and the residual stream---places where a linear map goes from a large dimension to a relatively smaller dimension, and therefore information <em>must</em> be stored more efficiently/compactly</li>
<li><strong>neuron superposition</strong> occurs when dim(activation_space) &lt; num_features, and is <em>computation</em> rather than <em>storage.</em> Computation occurs when info gets passed through nonlinearities, and n non-linearities attend to &gt;n features in this case.</li>
</ul>
<p>Consider a given neuron. A neuron is more likely to be <strong>polysemantic</strong> if the features it represents are sparse w.r.t. each other, and higher sparsity corresponds to more superposition in the general case. One reason we should expect superposition to be naturally occuring is that it will almost always make sense for networks to try to represent ever-more-sparse yet useful features, and these can be added to popular features at almost 0 cost. </p>
<p>Reading:</p>
<ul>
<li><a href="https://dynalist.io/d/n2ZWtnoYHrU1s4vnFSAQ519J#z=3br1psLRIjQCOv2T4RN3V6F2">Neel Nanda's Notes on Superposition</a> - good glossary and introduction</li>
<li><a href="https://transformer-circuits.pub/2022/toy_model/index.html">Toy Models of Superposition</a> - Anthropic's first investigations into the subject</li>
<li><a href="https://www.alignmentforum.org/posts/o6ptPu7arZrqRCxyz/200-cop-in-mi-exploring-polysemanticity-and-superposition">200 COP in MI: Exploring Polysemanticity and Superposition</a> - some concrete open problems to do with superposition </li>
<li><a href="https://arena3-chapter1-transformer-interp.streamlit.app/%5B1.4%5D_Superposition_&amp;_SAEs">ARENA 1.4: Superposition and SAEs</a> - great resource generally for hands-on learning</li>
<li><a href="https://transformer-circuits.pub/2023/toy-double-descent/index.html">Superposition, Memorization, and Double Descent</a> - to replicate</li>
</ul>

    </main>
    <nav>
        <ul>  
            <li>[<a href="/">Home</a>]</li>
            <li>[<a href="/now">Now</a>]</li>
            <li>[<a href="https://microdosinglucidity.com">Essays</a>]</li>
            <li>[<a href="/blog">Blog</a>]</li>
            <li>[<a href="/shelf">Shelf</a>]</li>
            <li>[<a href="https://twitter.com/yudhister_">Twitter</a>]</li>
            <li>[<a href="https://twitter.com/yudhister_">Curius</a>]</li>
        </ul>
    </nav>
</body>
</html>

